# Notas Intro Python — RosalesSilvestre

----------------------------------------
Sección A — Comando para invocar Python en mi máquina
- Comando elegido: python3

----------------------------------------
Sección B — ¿Qué es el REPL? (en mis palabras)
- Descripción breve (1–2 líneas):
El REPL (Read-Eval-Print Loop) es un entorno interactivo donde puedes escribir código Python línea por línea, ver los resultados inmediatamente y experimentar con expresiones sin necesidad de crear un archivo completo.

----------------------------------------
Sección C — Script mínimo `hola.py`
- Qué contiene (enumera los elementos que incluiste):
1. Un print() con un saludo
2. Una variable con el resultado de una operación aritmética y un print() mostrando ese resultado
3. Una función simple y un print() mostrando la llamada a esa función con un valor

- Qué observé al ejecutarlo (resumen corto de la salida):
Se imprimió el saludo, luego el resultado de la operación aritmética, y finalmente el resultado de la función llamada con un valor.

----------------------------------------
Sección D — Comandos/flags de Python ejecutados y observaciones
- -h: Mostró la ayuda general y las opciones de Python
- -V: Python 3.10.12
- -c "...": Ejecutó código pasado como texto y mostró la salida
- -i hola.py: Ejecutó el script y me dejó en REPL con variables/funciones cargadas
- -m this: Mostró el poema "The Zen of Python" con principios de diseño de Python
- -m antigravity: Abrió un cómic en el navegador sobre Python

----------------------------------------
Sección E — __pycache__ y archivos .pyc
- ¿Cuándo aparece __pycache__?: Aparece después de ejecutar un script Python que importa módulos
- ¿Qué contiene?: Contiene archivos .pyc (bytecode compilado) que Python genera para acelerar la carga de módulos
- -B (observación): No se creó __pycache__/ (no se escriben .pyc)
- -O (observación): Se crean .pyc optimizados; los assert no se evalúan
- -OO (observación): .pyc optimizados; además pueden eliminarse docstrings

----------------------------------------
Sección F — `dis` (inspección de bytecode)
- Comando que usé: python3 -c "import dis, hola; dis.dis(hola)"
- Lo que observé (menciona 1–2 cosas que notaste): Vi instrucciones de bytecode como LOAD_CONST, LOAD_NAME, CALL_FUNCTION, RETURN_VALUE que muestran cómo Python compila el código a instrucciones de bajo nivel

----------------------------------------
Sección G — Conclusión corta
- 1–3 líneas con tu reflexión principal:
Python ofrece múltiples formas de ejecutar código (REPL, scripts, módulos) y herramientas para inspeccionar su funcionamiento interno. El bytecode y __pycache__ muestran cómo Python optimiza la ejecución, mientras que las banderas permiten controlar el comportamiento del intérprete.

